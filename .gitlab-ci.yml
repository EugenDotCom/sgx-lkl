# do not use "latest" here, if you want this to work in the future
image: docker:latest

stages:
  - build
  - push

cache: &global_cache
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - host-musl/
      - lkl/
      - sgx-lkl-musl/
      - build/
    policy: pull-push

variables:
  #GIT_SUBMODULE_STRATEGY: normal
  # fill those if you have a proxy in your environment

# Use this if your GitLab runner does not use socket binding
services:
  - docker:dind
before_script:
  # docker login asks for the password to be passed through stdin for security
  # we use $CI_JOB_TOKEN here which is a special token provided by GitLab
  # - echo test $CI_REGISTRY_USER $CI_REGISTRY_PASSWORD $CI_REGISTRY
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    #- echo -n $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY

Build:
  stage: build
  script:
    - echo $UID
    # fetches the latest image (not failing if image is not found)
    - docker pull $CI_REGISTRY_IMAGE:latest || true
    # build sgx-lkl
    #- git clone https://github.com/lsds/sgx-lkl
    - SSH_AGENT_WORKAROUND="--volume $SSH_AUTH_SOCK:/ssh-agent --env SSH_AUTH_SOCK=/ssh-agent"
    - DOCKER_CMD="cd /sgx-lkl && make ${SIM} DEBUG=${DEBUG}"
    - SIM="sim"
    - VOLUME_MOUNTS=$PWD:/sgx-lkl

    - docker build --target builder -t lsds/sgx-lkl:build sgx-lkl
    - docker run --rm --privileged=true -v $VOLUME_MOUNTS $SSH_AGENT_WORKAROUND lsds/sgx-lkl:build /bin/bash -c "${DOCKER_CMD}"
    # builds the project, passing proxy variables, and vcs vars for LABEL
    # notice the cache-from, which is going to use the image we just pulled locally
    # the built image is tagged locally with the commit SHA, and then pushed to 
    # the GitLab registry
    #- >
    #  docker build
    #  --pull
    #  --build-arg VCS_REF=$CI_COMMIT_SHA
    #  --build-arg VCS_URL=$CI_PROJECT_URL
    #  --cache-from $CI_REGISTRY_IMAGE:latest
    #  --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    #  -f build/Dockerfile
    #  build
    #- docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

# Here, the goal is to tag the "master" branch as "latest"
Push latest:
  variables:
    # We are just playing with Docker here. 
    # We do not need GitLab to clone the source code.
    GIT_STRATEGY: none
  stage: push
  only:
    # Only "master" should be tagged "latest"
    - master
  script:
    # Because we have no guarantee that this job will be picked up by the same runner 
    # that built the image in the previous step, we pull it again locally
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    # Then we tag it "latest"
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    # Annnd we push it.
    - docker push $CI_REGISTRY_IMAGE:latest

# Finally, the goal here is to Docker tag any Git tag
# GitLab will start a new pipeline everytime a Git tag is created, which is pretty awesome
Push tag:
  variables:
    # Again, we do not need the source code here. Just playing with Docker.
    GIT_STRATEGY: none
  stage: push
  only:
    # We want this job to be run on tags only.
    - tags
  script:
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME